export interface AddFundRequest {
    /** The developer's account ID. */
    developerId: object;
    /** The amount to add in cent ( 1 USD = 100 cents ). */
    amount: object;
    /** The note or description for this payment. */
    description?: object;
    /** The expected date, which has type is ISO string, to schedule this payment.  Example: &quot;2022-03-16T04:29:30.519Z&quot; */
    date?: object;
}
export interface AddFundResponse {
    /** The current balance after fund is added. */
    balance: string;
}
export interface AddFundUsingCardRequest {
    /** Contain 4 types of payment names. It must contain one of these configuration, create-transaction, confirm-transaction, update-transaction-result. */
    type: object;
    /** The data form following by type request. */
    data: object;
}
export interface AddFundUsingCardResponse {
    /** Contain 4 types of payment names. It must contain one of these configuration, create-transaction, confirm-transaction, update-transaction-result. */
    type: object;
    /** Will depend on each type of request */
    data: object;
}
export interface GetFundRequest {
    /** The developer's account ID, can be found at API Key in Developer-Portal. */
    id: string;
}
export interface GetFundResponse {
    /** The current balance at the calling time. */
    balance: object;
}
export interface CreateTokenRequest {
    /** Developer's email. */
    email: string;
}
export interface CreateTokenResponse {
    /** Authorization token to access APIs. */
    authorization: string;
    /** An other token to renew the auth token. */
    refreshToken: string;
}
export interface KeyRotationRequest {
    /** Developer's email. */
    email: string;
}
export interface KeyRotationResponse {
    /** API Key token to access APIs. */
    apikey: string;
}
export interface RefreshTokenRequest {
    /** Developer's email. */
    email: string;
    /** RefreshToken returned from RefreshToken API. */
    refreshToken: string;
}
export interface RefreshTokenResponse {
    /** Authorization token to access APIs. */
    Authorization: string;
    /** An other token to renew the auth token. */
    RefreshToken: string;
}
export interface CreateDocumentsRequest {
    /** The list of document request forms information. */
    documents: object[];
}
export interface CreateDocumentsResponse {
    /** The list of document's forms. */
    documents: object;
}
export interface DeleteDocumentByIdRequest {
    /** The unique ID of the uploaded document to retrieve, can be found at CreateDocuments's response. */
    id: string;
}
export interface GetDocumentByIdRequest {
    /** The unique ID of the uploaded document to retrieve, can be found at CreateDocuments's response. */
    id: string;
    /** A fractal time tagging for request validity. */
    validity: object;
    /** The request signature to protect resource caching at edge */
    signature: string;
}
export interface GetDocumentByIdResponse {
    /** The protected resource URL for previewing the document. */
    url: string;
}
export interface ConfirmLetterRequest {
    /** The unique ID to track your letter, can be found at CreateLetter's response. */
    id: string;
    /** LetterObject's unique Tracking ID, can be found at CreateLetter's response. */
    trackingId: string;
    /** The transaction signature to confirm the letter, can be found at CreateLetter's response. */
    transaction: string;
}
export interface ConfirmLetterResponse {
    /** The unique ID to track your letter. */
    id: string;
    /** The tracking ID of letters batch. This ID is important to get tracking infomation. */
    trackingId: string;
    /** The array of letters status according to multiple recipients (one element for sending to single recipient request). */
    letters: object[];
    /** The calculated payment object { taxes: 12, total: 152, balance: 1008 } */
    payment: object;
}
export interface CreateLetterRequest {
    /** The unique ID to track your letter. If not set, autogenerated return by API. Only accept lowercase, uppercase, number and - letters. Max length is 36 */
    id?: string;
    /** The notification email for letter status updates. */
    email?: string;
    /** The postal sender address object in JSON format. */
    sender: object;
    /** The array of postal recipient addresses in JSON format. */
    recipients: object[];
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
}
export interface CreateLetterResponse {
    /** The unique ID to track your letter. */
    id: string;
    /** The tracking ID of letters batch. This ID is important to get tracking infomation. */
    trackingId: string;
    /** The array of letters status according to multiple recipients (one element for sending to single recipient request). */
    letters: object[];
    /** The calculated payment object { taxes: 12, total: 152, balance: 1008 } */
    payment: object;
    /** The transaction signature to confirm letter. */
    transaction: string;
}
export interface PreviewLetterRequest {
    /** LetterObject's unique ID, can be found at CreateLetter's response. */
    id: string;
}
export interface PreviewLetterResponse {
    /** The unique ID to track your letter. */
    id: string;
    /** The tracking ID of letters batch. This ID is important to get tracking infomation. */
    trackingId: string;
    /** The array of letters status according to multiple recipients (one element for sending to single recipient request). */
    letters: object[];
    /** The calculated payment object { taxes: 12, total: 152, balance: 1008 } */
    payment: object;
}
export interface GetStatementRequest {
    /** The start date of the statement report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
    fromDate: string;
    /** The end date of the statement report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate and at most 90 days later. */
    toDate: string;
    /** The selectable response fields in [TrackingLetter](#api-Types-ObjectTrackingletter) object should be returned. */
    includes?: string;
    /** The token used to retrieve the next data of the previous request */
    nextToken?: string;
    /** The limit number used to retrieve the volume of data. Value range: 1-10000 */
    limit?: object;
    /** A fractal time tagging for request validity. Size range: 1s-86400s(1 day) */
    validity: string;
    /** The request signature to protect resource caching at edge */
    signature: string;
}
export interface GetStatementResponse {
    /** The start date of the statement report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
    fromDate: string;
    /** The end date of the statement report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate and at most 90 days later. */
    toDate: string;
    /** The token used to retrieve the next data for the next request. it has no value if the data has been fully retrieved. */
    nextToken: string;
    /** The list of matching letters grouped by day. */
    days: object[];
}
export interface GetUpdatedRequestRequest {
    /** One or more LetterObject's unique Tracking ID, can be found at CreateLetter's response. */
    ids: string;
    /** The timestamp passed from params as query condition. */
    timestamp: string;
}
export interface GetUpdatedRequestResponse {
    /** The list of letters associated with TrackingID or timestamp. */
    tracking: object[];
}
export interface ConfirmUserRequest {
    /** This is email of user who sent request to create. */
    userEmail: string;
    /** This is token generated to validate request. */
    acceptableToken: string;
    /** This hex string provided for you before will be the way for us to validate who is invited to join the partner's group */
    signature: string;
}
export interface ConfirmUserResponse {
    /** will be &quot;success&quot; when everything is working exactly as expected. */
    connectStatus: object;
    /** is Id of user. */
    userId: object;
    /** is Developer's Account ID. */
    accountId: object;
}
export interface CreateUserConnectRequestRequest {
    /** This is email of user who sent request to create. */
    userEmail: string;
    /** The string to create signature for comparing. */
    nonce: string;
    /** The string to verify correct or not. */
    signature: string;
}
export interface CreateUserConnectRequestResponse {
    /** status of response. if no error, it will be true */
    success: string;
    /** This string will be used to verify the request of confirmation from client. */
    acceptableToken: string;
}
export interface CreateUserRequest {
    /** The user's email will being created for partner group. */
    email: string;
    /** The first name of a person or an organization. */
    firstName: string;
    /** The last name of a person or an organization. */
    lastName: string;
    /** The request signature to protect resource is unique. */
    signature: string;
}
export interface CreateUserResponse {
    /** is Id of user account. */
    userId: object;
    /** The user's email will being created for partner group. */
    email: string;
    /** The api key of the created user. */
    apiKey: string;
    /** The account id of the created user. */
    accountId: string;
    /** The authenticated user token */
    token: string;
    /** The session token for authenticated user */
    refreshToken: string;
}
export interface ExportAllStatementsRequest {
    /** The time of the beginning of data to export (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z). fromDate must be earlier than now at most 3 years. */
    fromDate: string;
    /** The time of the ending of data to export (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate and at most 90 days later. */
    toDate: string;
    /** The type of export file that you want to choose. */
    format?: string;
    /** The request signature to protect resource caching at edge. */
    signature: string;
    /** The time that the URL will be expired. */
    validity?: object;
}
export interface GetAllPartnerUsersRequest {
    /** This is the number of records that the demand needed. */
    limit?: string;
    /** This is the token for pagination, only if there are more record to take. */
    nextToken?: string;
}
export interface GetAllPartnerUsersResponse {
    /** is an array contain the partner user's information. */
    data: object[];
    /** A token use in paginating mechanism. */
    nextToken: object;
}
export interface GetMarginRateRequest {
    /** The date to check margin rate (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
    datetime?: string;
}
export interface GetMarginRateResponse {
    /** The status of this API when it called successfully. */
    success: boolean;
    /** The list of found margin rate object */
    data: object[];
}
export interface GetPartnerStatementRequest {
    /** This is userName of partner user need to get statement. */
    id: string;
    /** The start date of the statement report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z). fromDate must be earlier than now at most 3 years. */
    fromDate: string;
    /** The end date of the statement report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate and at most 90 days later. */
    toDate: string;
    /** The selectable response fields in comma separated list [printing.printColor, printing.duplex, printing.envelopSize, delivery.emailService, recipient.postalAddress.city, recipient.postalAddress.state, recipient.postalAddress.postcode, sender.postalAddress.city, sender.postalAddress.state, sender.postalAddress.postcode]. */
    includes?: string;
    /** The token used to retrieve the next data of the previous request */
    nextToken?: string;
    /** The limit number used to retrieve the volume of data. Value range: 10-1000 */
    limit?: object;
    /** The request signature to protect resource caching at edge */
    signature: string;
}
export interface GetPartnerStatementResponse {
    /** User name of partner user */
    userId: string;
    /** The token used to retrieve the next data for the next request. it has no value if the data has been fully retrieved. */
    nextToken: string;
    /** The list of matching letters grouped by day. */
    letters: object[];
}
export interface GetPartnerUserRequest {
    /** This is userName of partner user need to get information. */
    id: string;
}
export interface GetPartnerUserResponse {
    /** The partner user's information. */
    data: object;
}
export interface DeleteMarginRateRequest {
    /** The name of rateCode that you want to delete */
    rateCode: object;
}
export interface DeleteMarginRateResponse {
    /** status of response. if no error, it will be true */
    success: boolean;
}
export interface SetMarginRateRequest {
    /** price for printing color document calculating from second sheet and so on. */
    anotherPageColorPrice: object;
    /** price for printing black-and-white document calculating from second sheet and so on. */
    anotherPageWhitePrice: object;
    /** field of date (following ISO 8601), which to triggered configuration. */
    effectiveDate: string;
    /** price of first color sheet. */
    firstPageColorPrice: object;
    /** price of first black-and-white sheet. */
    firstPageWhitePrice: object;
    /** price of using certified postal service. */
    priceCertifiedMail: object;
    /** price of using first class postal service. */
    priceFirstClass: object;
    /** pricing of envelope size Flat Rate Envelope. */
    priceFlat: object;
    /** pricing of envelope size Large. */
    priceLarge: object;
    /** pricing of envelope size Medium. */
    priceMedium: object;
    /** pricing of envelope size Medium Flat Rate Box. */
    priceMediumFlat: object;
    /** pricing of envelope size Small. */
    priceSmall: object;
    /** pricing of Switch service. */
    priceSwitchService: object;
    /** alias name represent for the current margin rate information, this code should be unique for each effectiveDate. */
    rateCode: string;
}
export interface SetMarginRateResponse {
    /** status of response. if no error, it will be true */
    success: boolean;
    /** the margin rate that scheduled successfully */
    data: object;
}
export interface GetLetterStatusRequest {
    /** The start date of the letter status tracking report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
    fromDate?: string;
    /** The end date of the the letter status tracking report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate. The time range between fromDate and toDate less than 90 days. */
    toDate?: string;
    /** The date field used to sort in letter object (createdAt or updatedAt). Default: createdAt. */
    order?: string;
    /** A sort type of order field (ASC or DESC). Default: DESC. */
    sort?: string;
    /** The selectable response fields in [TrackingLetter] object should be returned. */
    includes?: string;
    /** The current page of letter report. The letter page start from 0. Default: 0. */
    page?: string;
    /** The limit number used to retrieve the letter records responses per page. Value range: 10-1000. Default: 20. */
    size?: string;
}
export interface GetLetterStatusResponse {
    /** The list of letters returned. */
    letters: object[];
    /** The pagination of the list letters. */
    pagination: object;
}
export interface GetTrackingByIdRequest {
    /** LetterObject's unique Tracking ID, can be found at CreateLetter's response. */
    id: string;
    /** The selectable response fields in LetterObject object should be returned. */
    includes?: string;
}
export interface GetTrackingByIdResponse {
    /** The TrackingID of the CreateLetter request. */
    id: string;
    /** The list of letters associated with a TrackingID. */
    letters: object[];
}
export interface AccountBalanceRequest {
    /** The total account balance in cent. */
    balance: object;
}
export interface AccountBalance {
    /** The total account balance in cent. */
    balance?: object;
}
export interface AccountObjectRequest {
    /** The account status of the current subscription. */
    status: string;
    /** The subscription type of the current account. */
    type: string;
    /** The actual remaining balance of the current subscription. */
    balance: object;
    /** The last changed date in the account object. */
    date?: string;
}
export interface AccountObject {
    /** The account status of the current subscription. */
    status?: string;
    /** The subscription type of the current account. */
    type?: string;
    /** The actual remaining balance of the current subscription. */
    balance?: object;
    /** The last changed date in the account object. */
    date?: string;
}
export interface AccountStatementRequest {
    /** The total account balance in cent. */
    balance: object;
}
export interface AccountStatement {
    /** The total account balance in cent. */
    balance?: object;
}
export interface AccountTransactionRequest {
    /** The actual amount in cent ( 1 USD = 100 ). */
    amount: object;
    /** The payment type of the transaction. */
    type: string;
    /** The actual payment status of the transaction. */
    status: string;
    /** The created date of the requested transaction. */
    createdAt: string;
    /** The last updated date of the requested transaction. */
    updatedAt: string;
    /** The affected date of the transaction in case it's scheduled. */
    affectedAt?: string;
}
export interface AccountTransaction {
    /** The actual amount in cent ( 1 USD = 100 ). */
    amount?: object;
    /** The payment type of the transaction. */
    type?: string;
    /** The actual payment status of the transaction. */
    status?: string;
    /** The created date of the requested transaction. */
    createdAt?: string;
    /** The last updated date of the requested transaction. */
    updatedAt?: string;
    /** The affected date of the transaction in case it's scheduled. */
    affectedAt?: string;
}
export interface DayStatementRequest {
    /** The date of the day in ISO format (2021-03-15). */
    day: string;
    /** The list of letters created on this specific day. */
    letters: object[];
}
export interface DayStatement {
    /** The date of the day in ISO format (2021-03-15). */
    day?: string;
    letters?: TrackingLetter[];
}
export interface DeliveryOptionRequest {
    /** The mail class to be sent, is one of (FIRSTCLASS | CERTIFIED). */
    emailService: string;
    /** The email address of a sender or notifier who want to receive the proof of delivery. */
    eReceipt?: string;
}
export interface DeliveryOption {
    /** The mail class to be sent, is one of (FIRSTCLASS | CERTIFIED). */
    emailService?: string;
    /** The email address of a sender or notifier who want to receive the proof of delivery. */
    eReceipt?: string;
}
export interface DocumentFormRequest {
    /** The document ID attached to this form upload. */
    documentId: string;
    /** The requested document origin file name send by customers. */
    fileName?: string;
    /** The requested document file type (always is the application/pdf file type). */
    fileType?: string;
    /** The document form upload fields. */
    form: object;
}
export interface DocumentForm {
    /** The document ID attached to this form upload. */
    documentId?: string;
    /** The requested document origin file name send by customers. */
    fileName?: string;
    /** The requested document file type (always is the application/pdf file type). */
    fileType?: string;
    /** The document form upload fields. */
    form?: object;
}
export interface DocumentObjectRequest {
    /** The document ID attached to this letter. */
    documentId?: string;
    /** The original name of this document. */
    fileName?: string;
}
export interface DocumentObject {
    /** The document ID attached to this letter. */
    documentId?: string;
    /** The original name of this document. */
    fileName?: string;
}
export interface ErrorObjectRequest {
    /** The error code was defined by system on the request. */
    code: string;
    /** The error message was defined by system on the request. */
    message: string;
    /** The status of the response. */
    status?: object;
    /** The unique identifier of the request. */
    requestId?: string;
}
export interface ErrorObject {
    /** The error code was defined by system on the request. */
    code?: string;
    /** The error message was defined by system on the request. */
    message?: string;
    /** The status of the response. */
    status?: object;
    /** The unique identifier of the request. */
    requestId?: string;
}
export interface FormRequestRequest {
    /** The document ID attached to this form upload. Auto generated ID if not defined. */
    documentId?: string;
    /** The origin file name (customer's concern if this is a sensitive information). */
    fileName: string;
    /** The uploaded document file type (only support the application/pdf file type). */
    fileType?: string;
}
export interface FormRequest {
    /** The document ID attached to this form upload. Auto generated ID if not defined. */
    documentId?: string;
    /** The origin file name (customer's concern if this is a sensitive information). */
    fileName?: string;
    /** The uploaded document file type (only support the application/pdf file type). */
    fileType?: string;
}
export interface FormUploadRequest {
    /** The POST form url to upload into our file server. */
    url: string;
    /** The parsed form fields (security fields include). */
    fields?: object;
}
export interface FormUpload {
    /** The POST form url to upload into our file server. */
    url?: string;
    /** The parsed form fields (security fields include). */
    fields?: object;
}
export interface FundObjectRequest {
    /** The number of money that you want to charge funds. */
    amount: object;
    /** is id of payment method. */
    data: object;
    /** is id of transaction, which inside response of request at type = createTransaction. */
    id: object;
    /** is payment token when getting payment method. */
    token: object;
    /** A standardization of money. */
    currency?: object;
    /** Save card information or not. */
    persistent?: object;
}
export interface FundObject {
    /** The number of money that you want to charge funds. */
    amount?: object;
    /** is id of payment method. */
    data?: object;
    /** is id of transaction, which inside response of request at type = createTransaction. */
    id?: object;
    /** is payment token when getting payment method. */
    token?: object;
    /** A standardization of money. */
    currency?: object;
    /** Save card information or not. */
    persistent?: object;
}
export interface KeyValueRequest {
    /** The key object value. */
    key: string;
    /** The value according to the key. */
    value: string;
}
export interface KeyValue {
    /** The key object value. */
    key?: string;
    /** The value according to the key. */
    value?: string;
}
export interface LetterObjectRequest {
    /** The unique ID of this letter object. Use for referencing to update this object. */
    id: string;
    /** The user email for receiving the notification update in case of system event. */
    email: string;
    /** The document IDs of pieces attached to this letter. */
    documents?: object[];
    /** The postal sender address object in JSON format. */
    sender: object;
    /** The object of postal recipient address in JSON format. */
    recipient: object;
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
}
export interface LetterObject {
    /** The unique ID of this letter object. Use for referencing to update this object. */
    id?: string;
    /** The user email for receiving the notification update in case of system event. */
    email?: string;
    documents?: DocumentObject[];
    /** The postal sender address object in JSON format. */
    sender?: object;
    /** The object of postal recipient address in JSON format. */
    recipient?: object;
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
}
export interface LetterStatementRequest {
    /** The total spent by sending letters. */
    amount: object;
    /** The none taxed amount of the letters' sent. */
    noneTaxed: object;
    /** The total taxes calculated on letters' sent. */
    taxed: object;
}
export interface LetterStatement {
    /** The total spent by sending letters. */
    amount?: object;
    /** The none taxed amount of the letters' sent. */
    noneTaxed?: object;
    /** The total taxes calculated on letters' sent. */
    taxed?: object;
}
export interface MarginRateRequest {
    /** price for printing color document calculating from second sheet and so on. */
    anotherPageColorPrice: object;
    /** price for printing black-and-white document calculating from second sheet and so on. */
    anotherPageWhitePrice: object;
    /** field of date (following ISO 8601), which to triggered configuration. */
    effectiveDate: string;
    /** price of first color sheet. */
    firstPageColorPrice: object;
    /** price of first black-and-white sheet. */
    firstPageWhitePrice: object;
    /** price of using certified postal service. */
    priceCertifiedMail: object;
    /** price of using first class postal service. */
    priceFirstClass: object;
    /** pricing of envelope size Flat Rate Envelope. */
    priceFlat: object;
    /** pricing of envelope size Large. */
    priceLarge: object;
    /** pricing of envelope size Medium. */
    priceMedium: object;
    /** pricing of envelope size Medium Flat Rate Box. */
    priceMediumFlat: object;
    /** pricing of envelope size Small. */
    priceSmall: object;
    /** pricing of Switch service. */
    priceSwitchService: object;
    /** alias name represent for the current margin rate information, this code should be unique for each effectiveDate. */
    rateCode: string;
}
export interface MarginRate {
    /** price for printing color document calculating from second sheet and so on. */
    anotherPageColorPrice?: object;
    /** price for printing black-and-white document calculating from second sheet and so on. */
    anotherPageWhitePrice?: object;
    /** field of date (following ISO 8601), which to triggered configuration. */
    effectiveDate?: string;
    /** price of first color sheet. */
    firstPageColorPrice?: object;
    /** price of first black-and-white sheet. */
    firstPageWhitePrice?: object;
    /** price of using certified postal service. */
    priceCertifiedMail?: object;
    /** price of using first class postal service. */
    priceFirstClass?: object;
    /** pricing of envelope size Flat Rate Envelope. */
    priceFlat?: object;
    /** pricing of envelope size Large. */
    priceLarge?: object;
    /** pricing of envelope size Medium. */
    priceMedium?: object;
    /** pricing of envelope size Medium Flat Rate Box. */
    priceMediumFlat?: object;
    /** pricing of envelope size Small. */
    priceSmall?: object;
    /** pricing of Switch service. */
    priceSwitchService?: object;
    /** alias name represent for the current margin rate information, this code should be unique for each effectiveDate. */
    rateCode?: string;
}
export interface PaginationRequest {
    /** The letters in single page. */
    perPage: object;
    /** The current page of letter pagination. */
    currentPage: object;
    /** The total page of letter pagination. */
    totalPages: object;
    /** The total letter of letter returned. */
    totalEntries: object;
    /** The next page of letter pagination. */
    nextPage: object;
    /** The previous page of letter pagination and is null when currentPage = 0. */
    previousPage: object;
    /** The relation of total letter (equal or estimated). */
    relation: object;
}
export interface Pagination {
    /** The letters in single page. */
    perPage?: object;
    /** The current page of letter pagination. */
    currentPage?: object;
    /** The total page of letter pagination. */
    totalPages?: object;
    /** The total letter of letter returned. */
    totalEntries?: object;
    /** The next page of letter pagination. */
    nextPage?: object;
    /** The previous page of letter pagination and is null when currentPage = 0. */
    previousPage?: object;
    /** The relation of total letter (equal or estimated). */
    relation?: object;
}
export interface PartnerStatementRequest {
    /** Id of letter */
    id: string;
    /** The calculated price base on this letter options. */
    pricing: object;
    /** Date time to create letter */
    createdAt: string;
    /** Latest date time to modify letter */
    updatedAt: string;
    /** Current letter tracking status (CREATED | SUBMITTED | DELIVERED | FAILED ...) */
    status: string;
    /** Current letter's transaction status [SUCCEEDED | FAILED | PENDING | CREATED | REFUNDED | CANCELLED | REJECTED | ERROR] */
    txnStatus: string;
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
    /** The postal recipient address object in JSON format. */
    recipient?: object;
    /** The postal sender address object in JSON format. */
    sender?: object;
}
export interface PartnerStatement {
    /** Id of letter */
    id?: string;
    /** The calculated price base on this letter options. */
    pricing?: object;
    /** Date time to create letter */
    createdAt?: string;
    /** Latest date time to modify letter */
    updatedAt?: string;
    /** Current letter tracking status (CREATED | SUBMITTED | DELIVERED | FAILED ...) */
    status?: string;
    /** Current letter's transaction status [SUCCEEDED | FAILED | PENDING | CREATED | REFUNDED | CANCELLED | REJECTED | ERROR] */
    txnStatus?: string;
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
    /** The postal recipient address object in JSON format. */
    recipient?: object;
    /** The postal sender address object in JSON format. */
    sender?: object;
}
export interface PartnerUserRequest {
    /** User name of partner user */
    userId: string;
    /** Email of partner user */
    email: string;
    /** First name of partner user */
    firstName: string;
    /** Last name of partner user */
    lastName: string;
    /** date time to create partner user */
    createdAt: string;
    /** Latest date time to modify partner user */
    updatedAt: string;
    /** The last time this user logged in to use the system. */
    lastConnectedAt: string;
}
export interface PartnerUser {
    /** User name of partner user */
    userId?: string;
    /** Email of partner user */
    email?: string;
    /** First name of partner user */
    firstName?: string;
    /** Last name of partner user */
    lastName?: string;
    /** date time to create partner user */
    createdAt?: string;
    /** Latest date time to modify partner user */
    updatedAt?: string;
    /** The last time this user logged in to use the system. */
    lastConnectedAt?: string;
}
export interface PaymentObjectRequest {
    /** The tax structure of the payment request. */
    taxes: object;
    /** The total amount to be billed for this request. */
    total: object;
    /** The actual remaining balance of the current subscription. */
    balance: object;
}
export interface PaymentObject {
    /** The tax structure of the payment request. */
    taxes?: object;
    /** The total amount to be billed for this request. */
    total?: object;
    /** The actual remaining balance of the current subscription. */
    balance?: object;
}
export interface PostalAddressRequest {
    /** The first line of a postal address (aka street address). */
    address1: string;
    /** The second line of a postal address (aka building, floor etc.,). */
    address2?: string;
    /** The state of the address above. */
    state: string;
    /** The city of the address above. */
    city: string;
    /** The postcode of this postal address. */
    postcode: string;
    /** The country of this postal address. Currently support only in US. */
    country?: string;
}
export interface PostalAddress {
    /** The first line of a postal address (aka street address). */
    address1?: string;
    /** The second line of a postal address (aka building, floor etc.,). */
    address2?: string;
    /** The state of the address above. */
    state?: string;
    /** The city of the address above. */
    city?: string;
    /** The postcode of this postal address. */
    postcode?: string;
    /** The country of this postal address. Currently support only in US. */
    country?: string;
}
export interface PricingObjectRequest {
    /** The calculated price of the letter with options to be sent. */
    price: object;
    /** The calculated taxes for this letter is being sent. */
    taxes: object;
    /** The reduction cost for this letter base on promotion or campaign. */
    reduction?: object;
}
export interface PricingObject {
    /** The calculated price of the letter with options to be sent. */
    price?: object;
    /** The calculated taxes for this letter is being sent. */
    taxes?: object;
    /** The reduction cost for this letter base on promotion or campaign. */
    reduction?: object;
}
export interface PrintingOptionRequest {
    /** The printing color option (with color if true). Default is false. */
    printColor?: boolean;
    /** The printing request for one side or two side paper. Default is true. */
    duplex?: boolean;
    /** The envelope size in standard format (Autoselect (default) | Small | Medium | Large | Flat | MediumFlat ). */
    envelopSize?: string;
}
export interface PrintingOption {
    /** The printing color option (with color if true). Default is false. */
    printColor?: boolean;
    /** The printing request for one side or two side paper. Default is true. */
    duplex?: boolean;
    /** The envelope size in standard format (Autoselect (default) | Small | Medium | Large | Flat | MediumFlat ). */
    envelopSize?: string;
}
export interface RecipientObjectRequest {
    /** The document IDs of pieces attached to this letter. */
    documents?: object;
    /** The first name of a person or the name of an ogranization who receive this letter. */
    firstName: string;
    /** The last name or family name of a person or the department of an ogranization who receive this letter. */
    lastName: string;
    /** The complement name of the department or an ogranization who receive this letter. */
    complementName?: string;
    /** The postal address of a person who receive this letter. */
    postalAddress: object;
    /** The custom printing option object. */
    printing?: object;
    /** The custom delivery option object. */
    delivery?: object;
}
export interface RecipientObject {
    /** The document IDs of pieces attached to this letter. */
    documents?: object;
    /** The first name of a person or the name of an ogranization who receive this letter. */
    firstName?: string;
    /** The last name or family name of a person or the department of an ogranization who receive this letter. */
    lastName?: string;
    /** The complement name of the department or an ogranization who receive this letter. */
    complementName?: string;
    /** The postal address of a person who receive this letter. */
    postalAddress?: object;
    /** The custom printing option object. */
    printing?: object;
    /** The custom delivery option object. */
    delivery?: object;
}
export interface SenderObjectRequest {
    /** The first name of a person or an ogranization. */
    firstName: string;
    /** The last name or family name of a person or an ogranization. */
    lastName: string;
    /** The company name of an ogranization. */
    companyName?: string;
    /** The postal address object. */
    postalAddress: object;
}
export interface SenderObject {
    /** The first name of a person or an ogranization. */
    firstName?: string;
    /** The last name or family name of a person or an ogranization. */
    lastName?: string;
    /** The company name of an ogranization. */
    companyName?: string;
    /** The postal address object. */
    postalAddress?: object;
}
export interface TrackingLetterRequest {
    /** The unique ID of this letter object. Use for referencing to update this object. */
    id: string;
    /** The tracking list of this letter after sending to postal service. */
    tracking: object[];
    /** The calculated price base on this letter options. */
    pricing: object;
    /** The created date time of the tracking status. */
    createdAt: string;
    /** The last updated date time of the tracking status. */
    updatedAt: string;
    /** The document IDs of pieces attached to this letter. */
    documents?: object[];
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
}
export interface TrackingLetter {
    /** The unique ID of this letter object. Use for referencing to update this object. */
    id?: string;
    tracking?: TrackingObject[];
    /** The calculated price base on this letter options. */
    pricing?: object;
    /** The created date time of the tracking status. */
    createdAt?: string;
    /** The last updated date time of the tracking status. */
    updatedAt?: string;
    documents?: DocumentObject[];
    /** The custom printing option object:  See PrintingOption. This parameter is overridable in each recipient. */
    printing?: object;
    /** The custom delivery option object:  See DeliveryOption. This parameter is overridable in each recipient. */
    delivery?: object;
}
export interface TrackingObjectRequest {
    /** The tracking status of a letter (CREATED | SUBMITTED | DELIVERED | FAILED ...) */
    status: string;
    /** The affected date of the tracking status. */
    date: string;
    /** The USPS tracking code if any. */
    trackingCode?: string;
    /** The prove of receipt file captured when a CERTIFIED letter status is updated to DELIVERED. */
    proofOfReceiptFile?: string;
}
export interface TrackingObject {
    /** The tracking status of a letter (CREATED | SUBMITTED | DELIVERED | FAILED ...) */
    status?: string;
    /** The affected date of the tracking status. */
    date?: string;
    /** The USPS tracking code if any. */
    trackingCode?: string;
    /** The prove of receipt file captured when a CERTIFIED letter status is updated to DELIVERED. */
    proofOfReceiptFile?: string;
}
export interface TrackingRequestRequest {
    /** The unique ID of this letter object. Use for referencing to update this object. */
    id: string;
    /** The info of the TrackingLetter. */
    letterInfo: object;
    /** The created date time of the tracking request status. */
    createdAt: string;
    /** The last updated date time of the tracking request status. */
    updatedAt: string;
    /** The status of the tracking letter. */
    status: string;
    /** The status of the tracking letter. */
    error?: object;
}
export interface TrackingRequest {
    /** The unique ID of this letter object. Use for referencing to update this object. */
    id?: string;
    /** The info of the TrackingLetter. */
    letterInfo?: object;
    /** The created date time of the tracking request status. */
    createdAt?: string;
    /** The last updated date time of the tracking request status. */
    updatedAt?: string;
    /** The status of the tracking letter. */
    status?: string;
    /** The status of the tracking letter. */
    error?: object;
}
export interface SubscribeEventsRequest {
    /** The server url to callback on events. */
    url: string;
    /** The HTTP method of webhook callback. Example: GET, POST, PUT. */
    method: string;
    /** The nonce of webhook signature. */
    nonce: string;
    /** The list of events to listen. Example: SystemUpdate, TrackingChanged, CreateLetter, ConfirmLetter, StatementComplete. */
    events: string[];
}
export interface SubscribeEventsResponse {
    /** The signing key to hash callback. */
    signatureKey: string;
}
export interface UnsubscribeEventsRequest {
    /** The list of events to listen. Example: SystemUpdate, TrackingChanged, CreateLetter, ConfirmLetter, StatementComplete. */
    removeEvents: string[];
}
export interface UnsubscribeEventsResponse {
    /** The list of existing events to listen. */
    events: string[];
}
import { AxiosInstance, AxiosRequestConfig, ResponseType } from "axios";
import FormData = require("form-data");
export type QueryParamsType = Record<string | number, any>;
export interface FullRequestParams extends Omit<AxiosRequestConfig, "data" | "params" | "url" | "responseType"> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseType;
    /** request body */
    body?: unknown;
}
export type RequestParams = Omit<FullRequestParams, "body" | "method" | "query" | "path">;
export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, "data" | "cancelToken"> {
    securityWorker?: (securityData: SecurityDataType | null) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;
    secure?: boolean;
    format?: ResponseType;
}
export declare enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded",
    Text = "text/plain"
}
export declare class HttpClient<SecurityDataType = unknown> {
    instance: AxiosInstance;
    private securityData;
    private securityWorker?;
    private secure?;
    private format?;
    constructor({ securityWorker, secure, format, ...axiosConfig }?: ApiConfig<SecurityDataType>);
    setSecurityData: (data: SecurityDataType | null) => void;
    protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig;
    protected stringifyFormItem(formItem: unknown): string;
    protected createFormData(input: Record<string, unknown>): FormData;
    request: <T = any, _E = any>({ secure, path, type, query, format, body, ...params }: FullRequestParams) => Promise<T>;
}
/**
 * @title Switch APIs Documentation
 * @version 0.5.0
 * @baseUrl https://api.switchmail.com
 *
 * This is the official document of Switch APIs for sending a letter. Applicable for Switch's Developer account only. You need an account for using this API service.
 */
export declare class SwitchmailApi<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    account: {
        /**
         * No description
         *
         * @tags Account
         * @name FundsCreate
         * @summary You need to save card information at billing page first.
         * @request POST:/account/{developerId}/funds
         */
        fundsCreate: (developerId: string, body: number, params?: RequestParams) => Promise<AddFundResponse>;
        /**
         * No description
         *
         * @tags Account
         * @name PaymentCreate
         * @summary Dataflow: When the user adds a fund with an amount from the Partner's Application, the request will be directly sent to SwitchAPI which contains Authorization (Token can be created at Create Token) and a number of amounts (in the cent). A transaction will be made by Payment Gateway and then Partner's Application. While doing it, the Client needs to fill in the card information to create a payment method from Payment Gateway. Combining those data, we can start to confirm payment transaction. However, if the type of client's card is 3D or 3DS, we need one more step to confirm the transaction from the customer. One link from Card Issuer will be sent to the Partner's Application that needs to be popped up for user confirmation. After all, the payment transaction will be completed and Partner's Application can take the newest information of account balance from SwitchAPI You can test add fund here.
         * @request POST:/account/{accountId}/payment
         */
        paymentCreate: (accountId: string, body: string, params?: RequestParams) => Promise<AddFundUsingCardResponse>;
        /**
         * No description
         *
         * @tags Account
         * @name FundsDetail
         * @summary Get the remaining amount of the account. Provide the account's id then the API will return the remaining amount of this account.
         * @request GET:/account/{id}/funds
         */
        fundsDetail: (id: string, params?: RequestParams) => Promise<GetFundResponse>;
    };
    auth: {
        /**
         * No description
         *
         * @tags Authentication
         * @name TokenCreate
         * @summary Create the authorization token for other API. Provide the parameters then the API will return your token. Attention:  Should call it once every 30 seconds. Can use RefreshToken API to make a new token. The refresh token can use for duration 30 days. After that period, another call to CreateToken API is necessary.
         * @request POST:/auth/token
         */
        tokenCreate: (body: CreateTokenRequest, params?: RequestParams) => Promise<CreateTokenResponse>;
        /**
         * No description
         *
         * @tags Authentication
         * @name RenewCreate
         * @request POST:/auth/renew
         */
        renewCreate: (body: KeyRotationRequest, params?: RequestParams) => Promise<KeyRotationResponse>;
        /**
         * No description
         *
         * @tags Authentication
         * @name RefreshCreate
         * @summary Refresh the authorization token to make the new one if the old token has expired. Provide the parameters then the API will return new authorization token.
         * @request POST:/auth/refresh
         */
        refreshCreate: (body: RefreshTokenRequest, params?: RequestParams) => Promise<RefreshTokenResponse>;
    };
    documents: {
        /**
         * No description
         *
         * @tags Documents
         * @name DocumentsCreate
         * @summary Get the forms signed with switch-api file's storage to upload documents. Provide the parameters then the API will create the forms in switch-mail storage then return information of these documents. SwitchMail implements content deduplication mechanism to protect itself from burst/replay requests. To avoid this, let make another difference one or try in the next few minutes.
         * @request POST:/documents
         */
        documentsCreate: (body: CreateDocumentsRequest, params?: RequestParams) => Promise<CreateDocumentsResponse>;
        /**
         * No description
         *
         * @tags Documents
         * @name DocumentsDelete
         * @summary Delete the document if it's no longer in use. Provide the document's id then the API will find your letter in system and delete it.
         * @request DELETE:/documents/{id}
         */
        documentsDelete: (id: string, params?: RequestParams) => Promise<void>;
        /**
         * No description
         *
         * @tags Documents
         * @name DocumentsDetail
         * @summary Retrieves an URL to download your document. Provide the parameters then the API will return the corresponding document.
         * @request GET:/documents/{id}
         */
        documentsDetail: (id: string, query: {
            /** A fractal time tagging for request validity. */
            validity: number;
            /** The request signature to protect resource caching at edge */
            signature: string;
        }, params?: RequestParams) => Promise<GetDocumentByIdResponse>;
    };
    letters: {
        /**
         * No description
         *
         * @tags Letters
         * @name ConfirmCreate
         * @summary Confirm and pay the letter which was created before. Provide the parameters then the API will send your letter to the print-service provider, will charge you the letter then return the letter's data. SwitchMail implements content deduplication mechanism to protect itself from burst/replay requests. To avoid this, let make another difference one or try in the next few minutes.
         * @request POST:/letters/{id}/confirm
         */
        confirmCreate: (id: string, body: ConfirmLetterRequest, params?: RequestParams) => Promise<ConfirmLetterResponse>;
        /**
         * No description
         *
         * @tags Letters
         * @name LettersCreate
         * @summary Create the letter in switch-mail system. Provide the parameters then the API will create the letter then return it's data. Don't hesitate, You will not be charged util you confirm it. SwitchMail implements content deduplication mechanism to protect itself from burst/replay requests. To avoid this, let make another difference one or try in the next few minutes.
         * @request POST:/letters
         */
        lettersCreate: (body: CreateLetterRequest, params?: RequestParams) => Promise<CreateLetterResponse>;
        /**
         * No description
         *
         * @tags Letters
         * @name PreviewDetail
         * @summary Preview the letter which was created before. Provide the parameters then the API will find your letter in system and return its data.
         * @request GET:/letters/{id}/preview
         */
        previewDetail: (id: string, params?: RequestParams) => Promise<PreviewLetterResponse>;
    };
    reports: {
        /**
         * No description
         *
         * @tags Reports
         * @name StatementList
         * @summary Get the statement of the letter which was created in the time range. Provide the parameters then the API will find your letter in system and return its data. If the nextToken field has value, which means there is still data that can be retrieved.  Please call the next request with the value of the nextToken field.
         * @request GET:/reports/statement
         */
        statementList: (query: {
            /** The start date of the statement report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
            fromDate: string;
            /** The end date of the statement report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate and at most 90 days later. */
            toDate: string;
            /** The selectable response fields in [TrackingLetter](#api-Types-ObjectTrackingletter) object should be returned. */
            includes?: string;
            /** The token used to retrieve the next data of the previous request */
            nextToken?: string;
            /** The limit number used to retrieve the volume of data. Value range: 1-10000 */
            limit?: number;
            /** A fractal time tagging for request validity. Size range: 1s-86400s(1 day) */
            validity: string;
            /** The request signature to protect resource caching at edge */
            signature: string;
        }, params?: RequestParams) => Promise<GetStatementResponse>;
    };
    tracking: {
        /**
         * No description
         *
         * @tags Request_Trackings
         * @name TrackingList
         * @summary Get all tracking of the letters which was created before. Provide the parameters then the API will find your request in system and return its data.
         * @request GET:/tracking
         */
        trackingList: (timestamp: string, query: {
            /** One or more LetterObject's unique Tracking ID, can be found at CreateLetter's response. */
            ids: string;
        }, params?: RequestParams) => Promise<GetUpdatedRequestResponse>;
    };
    user: {
        /**
         * No description
         *
         * @tags Reseller
         * @name ConnectUpdate
         * @summary This API will help to engage user to partner group for existing user who has invited by partner admin by calling 2 - ConnectUser. And the parameter acceptableToken returned from it will be the input of the request
         * @request PUT:/user/connect
         */
        connectUpdate: (body: ConfirmUserRequest, params?: RequestParams) => Promise<ConfirmUserResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name ConnectCreate
         * @summary We have two kinds of users, the first one is an admin who controls a group and the second one is client. When the admin wants to add a client to their group, he will send a pending request to the client's account. The approval will be executed when the client confirms the pending request. After that, the client's account will be immediately added to a partner's group
         * @request POST:/user/connect
         */
        connectCreate: (body: CreateUserConnectRequestRequest, params?: RequestParams) => Promise<CreateUserConnectRequestResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name CreateCreate
         * @summary Create a partner's user in switch-mail system. Provide the parameters then the API will create the user then return user's api key.
         * @request POST:/user/create
         */
        createCreate: (body: CreateUserRequest, params?: RequestParams) => Promise<CreateUserResponse>;
    };
    reseller: {
        /**
         * No description
         *
         * @tags Reseller
         * @name ReportsStatementCreate
         * @summary This method will export all statement information of all users in the admin group. Retrieve all activities and billing summary of all users of the partner’s account, export CSV or Excel file, and return the download link. Endpoint will have X-Invocation-Type at headers is Event (unchangeable) so the response will have requestId. You can find the real response by using this field as an input for GetUpdatedRequest.
         * @request POST:/reseller/reports/statement
         */
        reportsStatementCreate: (body: ExportAllStatementsRequest, params?: RequestParams) => Promise<any>;
        /**
         * No description
         *
         * @tags Reseller
         * @name ReportsUsersList
         * @summary Get all users of the partner’s account. This method can only be called with a partner admin permission level. The response can include a field named “nextToken”. This token can be used to call again this method to get the next page of data (if current response doesn’t fit on only one page).
         * @request GET:/reseller/reports/users
         */
        reportsUsersList: (query?: {
            /** This is the number of records that the demand needed. */
            limit?: string;
            /** This is the token for pagination, only if there are more record to take. */
            nextToken?: string;
        }, params?: RequestParams) => Promise<GetAllPartnerUsersResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name RatesList
         * @summary Get the margin rate of the group admin. Provide the payload then the API will return admin margin.
         * @request GET:/reseller/rates
         */
        ratesList: (query?: {
            /** The date to check margin rate (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
            datetime?: string;
        }, params?: RequestParams) => Promise<GetMarginRateResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name RatesDelete
         * @summary This endpoint will delete the rateCode that you already saved before
         * @request DELETE:/reseller/rates
         */
        ratesDelete: (rateCode: string, params?: RequestParams) => Promise<DeleteMarginRateResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name RatesCreate
         * @summary This endpoint will save the new rate called Margin Rate into database then return success after completed.
         * @request POST:/reseller/rates
         */
        ratesCreate: (body: SetMarginRateRequest, params?: RequestParams) => Promise<SetMarginRateResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name ReportsStatementDetail
         * @summary Get one specific user of the partner’s account. This method can only be called with a partner admin permission level.
         * @request GET:/reseller/reports/statement/{id}
         */
        reportsStatementDetail: (id: string, query: {
            /** The start date of the statement report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z). fromDate must be earlier than now at most 3 years. */
            fromDate: string;
            /** The end date of the statement report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate and at most 90 days later. */
            toDate: string;
            /** The selectable response fields in comma separated list [printing.printColor, printing.duplex, printing.envelopSize, delivery.emailService, recipient.postalAddress.city, recipient.postalAddress.state, recipient.postalAddress.postcode, sender.postalAddress.city, sender.postalAddress.state, sender.postalAddress.postcode]. */
            includes?: string;
            /** The token used to retrieve the next data of the previous request */
            nextToken?: string;
            /** The limit number used to retrieve the volume of data. Value range: 10-1000 */
            limit?: number;
            /** The request signature to protect resource caching at edge */
            signature: string;
        }, params?: RequestParams) => Promise<GetPartnerStatementResponse>;
        /**
         * No description
         *
         * @tags Reseller
         * @name ReportsUsersDetail
         * @summary Get one specific user of the partner’s account. This method can only be called with a partner admin permission level.
         * @request GET:/reseller/reports/users/{id}
         */
        reportsUsersDetail: (id: string, params?: RequestParams) => Promise<GetPartnerUserResponse>;
    };
    trackings: {
        /**
         * No description
         *
         * @tags Trackings
         * @name TrackingsList
         * @summary Get the status of the letter which was created in the time range. Provide the parameters then the API will find your letter in system and return its data.
         * @request GET:/trackings
         */
        trackingsList: (query?: {
            /** The start date of the letter status tracking report (ISO format: 2021-12-01 meaning 2021-12-01T00:00:00.000Z) */
            fromDate?: string;
            /** The end date of the the letter status tracking report (ISO format: 2021-12-07 meaning 2021-12-07T23:59:59.999Z). toDate must be greater than fromDate. The time range between fromDate and toDate less than 90 days. */
            toDate?: string;
            /** The date field used to sort in letter object (createdAt or updatedAt). Default: createdAt. */
            order?: string;
            /** A sort type of order field (ASC or DESC). Default: DESC. */
            sort?: string;
            /** The selectable response fields in [TrackingLetter] object should be returned. */
            includes?: string;
            /** The current page of letter report. The letter page start from 0. Default: 0. */
            page?: string;
            /** The limit number used to retrieve the letter records responses per page. Value range: 10-1000. Default: 20. */
            size?: string;
        }, params?: RequestParams) => Promise<GetLetterStatusResponse>;
        /**
         * No description
         *
         * @tags Trackings
         * @name TrackingsDetail
         * @summary Get the tracking of the letter which was created before. Provide the parameters then the API will find your letter in system and return its data.
         * @request GET:/trackings/{id}
         */
        trackingsDetail: (id: string, query?: {
            /** The selectable response fields in LetterObject object should be returned. */
            includes?: string;
        }, params?: RequestParams) => Promise<GetTrackingByIdResponse>;
    };
    webhook: {
        /**
         * No description
         *
         * @tags WebHook
         * @name SubscribeUpdate
         * @request PUT:/webhook/subscribe
         */
        subscribeUpdate: (body: SubscribeEventsRequest, params?: RequestParams) => Promise<SubscribeEventsResponse>;
        /**
         * No description
         *
         * @tags WebHook
         * @name UnsubscribeUpdate
         * @request PUT:/webhook/unsubscribe
         */
        unsubscribeUpdate: (body: UnsubscribeEventsRequest, params?: RequestParams) => Promise<UnsubscribeEventsResponse>;
    };
}
